<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive MCMC Dashboard</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 8px;  
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
        }
        .dashboard-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }
        .plot-column {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 270px; /* Adjusted width */
        }
        .info-column {
            background-color: #ffffff;
            padding: 25px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 250px;
        }
        h1, h2, h3 {
            color: #0056b3;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }
        h3 {
            text-align: center;
            border-bottom: none;
            margin-bottom: 5px;
            font-size: 0.9em; /* Smaller font for smaller plots */
        }
        canvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
        }
        .marginals-container {
            display: flex;
            flex-direction: column; 
            align-items: center;
            gap: 10px; /* Reduced gap */
            margin-top: 15px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            align-items: flex-start;
        }
        .controls div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="number"], input[type="range"] {
            font-size: 16px;
        }
        input[type="number"] { width: 60px; }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.2s;
            width: 100%;
        }
        button:hover { background-color: #0056b3; }
    </style>
</head>
<body>

    <div class="dashboard-container">
        
        <div class="plot-column">
            <h1>MCMC Animation</h1>
            <canvas id="mcmcCanvas" width="250" height="250"></canvas>
            <div class="marginals-container">
                <div >
                    <h3>Marginal Distribution of X</h3>
  
                    <canvas id="marginalXCanvas" width="50" height="75"></canvas>
                </div>
                <div>
                    <h3>Marginal Distribution of Y</h3>
                    <canvas id="marginalYCanvas" width="50" height="75"></canvas>
                </div>
            </div>
        </div>

        <div class="info-column">
            <h2>Controls & Analysis</h2>
            <p>
                This animation visualizes the <strong>Metropolis-Hastings</strong> algorithm sampling from a Bivariate normal distribution indicated by the shaded elypses.
            </p>
            Choose the number of points to be sampled and the speed of the animation
            <h3>The Animation</h3>
            <ul>
                <li><strong>Arrow Red:</strong> Show a proposed jump that was rejectedand no point is sampled.</li>
                <li><strong>Arrow Blue:</strong> Show a proposed jump that was accepted and the point is sampled.</li>
                <li><strong>Dots:</strong> Sampled point.</li>
                <li><strong>Histograms:</strong> Show the marginal distributions of sampled points.</li>
            </ul>
            <div class="controls">
                <div>
                    <label for="numPoints">Number of Points:</label>
                    <input type="number" id="numPoints" value="500" min="5" max="10000">
                </div>
                <div>
                    <label for="speedSlider">Speed (Delay):</label>
                    <input type="range" id="speedSlider" min="0" max="800" value="800" step="10">
                    <span id="speedValue">800 ms</span>
                </div>
            </div>
            <button id="restartButton">Restart Animation</button>
        </div>

    </div>

    <script>
        // Setup
        const canvas = document.getElementById('mcmcCanvas');
        const ctx = canvas.getContext('2d');
        const canvasSize = 250; 
        
        const marginalXCanvas = document.getElementById('marginalXCanvas');
        const marginalXCtx = marginalXCanvas.getContext('2d');
        const marginalYCanvas = document.getElementById('marginalYCanvas');
        const marginalYCtx = marginalYCanvas.getContext('2d');

        const restartButton = document.getElementById('restartButton');
        const numPointsInput = document.getElementById('numPoints');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue');

        let n_iterations = 500;
        let stepDelay = 150;

        const start_point = { x: 0.5, y: 0.5 };
        const proposal_std_dev = 3.0;
        const targetMean = { x: 5, y: 5 };
        const targetStdDev = { x: 1, y: 1 };
        const targetCorrelation = 0.8;
        const domain = { min: 0, max: 10 };

        let history = [];
        let chainPath = [];
        let currentStep = 0;
        let animationFrameId;
        let lastUpdateTime = 0;
        
        let yMaxCountX, yMaxCountY;
        const numBins = 20;
        const binWidth = (domain.max - domain.min) / numBins;

        // Normal distribution
        function random_normal() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        function pdf_bivariate_normal(x, y, mean, stdDev, rho) {
            const z = ((x - mean.x) ** 2 / stdDev.x ** 2) - (2 * rho * (x - mean.x) * (y - mean.y) / (stdDev.x * stdDev.y)) + ((y - mean.y) ** 2 / stdDev.y ** 2);
            const denominator = 2 * Math.PI * stdDev.x * stdDev.y * Math.sqrt(1 - rho ** 2);
            return Math.exp(-z / (2 * (1 - rho ** 2))) / denominator;
        }
        function pdf_normal(x, mean, stdDev) {
            return Math.exp(-0.5 * ((x - mean) / stdDev) ** 2) / (stdDev * Math.sqrt(2 * Math.PI));
        }

        // MCMC
        function runMCMC(num_steps) {
            let current_point = { ...start_point };
            const fullHistory = [];
            for (let i = 0; i < num_steps; i++) {
                const jump = { x: random_normal() * proposal_std_dev, y: random_normal() * proposal_std_dev };
                const proposal_point = { x: current_point.x + jump.x, y: current_point.y + jump.y };
                const p_proposal = pdf_bivariate_normal(proposal_point.x, proposal_point.y, targetMean, targetStdDev, targetCorrelation);
                const p_current = pdf_bivariate_normal(current_point.x, current_point.y, targetMean, targetStdDev, targetCorrelation);
                const acceptance_ratio = p_proposal / p_current;
                let accepted = (Math.random() < acceptance_ratio);
                fullHistory.push({ start: { ...current_point }, proposal: proposal_point, accepted: accepted });
                if (accepted) {
                    current_point = { ...proposal_point };
                }
            }
            return fullHistory;
        }

        // Plots and arrows
        function toCanvasCoords(point) {
            const scale = canvasSize / (domain.max - domain.min);
            return { x: (point.x - domain.min) * scale, y: canvasSize - (point.y - domain.min) * scale };
        }
        function drawDistributionContours() {
            const center = toCanvasCoords(targetMean);
            const scale = canvasSize / (domain.max - domain.min);
            const varX = targetStdDev.x ** 2; const varY = targetStdDev.y ** 2; const covXY = targetCorrelation * targetStdDev.x * targetStdDev.y;
            const term1 = varX + varY; const term2 = Math.sqrt((varX - varY) ** 2 + 4 * covXY ** 2);
            const eigenvalue1 = (term1 + term2) / 2; const eigenvalue2 = (term1 - term2) / 2;
            const semiAxis1 = Math.sqrt(eigenvalue1); const semiAxis2 = Math.sqrt(eigenvalue2);
            const angle = 0.5 * Math.atan2(2 * covXY, varX - varY);
            for (let i = 3; i > 0; i--) {
                ctx.beginPath();
                ctx.fillStyle = `rgba(173, 216, 230, ${0.12 * (4-i)})`;
                ctx.ellipse(center.x, center.y, i * semiAxis1 * scale, i * semiAxis2 * scale, -angle, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        function drawBackground() {
            ctx.clearRect(0, 0, canvasSize, canvasSize);
            ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 0.5;
            for (let i = domain.min; i <= domain.max; i++) {
                const p = toCanvasCoords({ x: i, y: i });
                ctx.beginPath(); ctx.moveTo(p.x, 0); ctx.lineTo(p.x, canvasSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, p.y); ctx.lineTo(canvasSize, p.y); ctx.stroke();
            }
            drawDistributionContours();
        }
        function drawArrow(from, to, color, lineWidth = 1.5) {
            const headlen = 6; // Adjusted for smaller size
            const canvasFrom = toCanvasCoords(from); const canvasTo = toCanvasCoords(to);
            const dx = canvasTo.x - canvasFrom.x; const dy = canvasTo.y - canvasFrom.y;
            const angle = Math.atan2(dy, dx);
            ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = lineWidth;
            ctx.beginPath(); ctx.moveTo(canvasFrom.x, canvasFrom.y); ctx.lineTo(canvasTo.x, canvasTo.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(canvasTo.x, canvasTo.y);
            ctx.lineTo(canvasTo.x - headlen * Math.cos(angle - Math.PI / 6), canvasTo.y - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(canvasTo.x - headlen * Math.cos(angle + Math.PI / 6), canvasTo.y - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath(); ctx.fill();
        }
        function drawPoint(point, color, size = 2) { // Adjusted for smaller size
            const canvasPoint = toCanvasCoords(point);
            ctx.beginPath();
            ctx.arc(canvasPoint.x, canvasPoint.y, size, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        function drawMarginalCurve(mCtx, mean, stdDev) {
            const width = mCtx.canvas.width;
            const height = mCtx.canvas.height;
            const scaleX = width / (domain.max - domain.min);
            const maxPdf = pdf_normal(mean, mean, stdDev);
            const scaleY = (height * 0.8) / maxPdf;
            mCtx.beginPath();
            mCtx.strokeStyle = 'rgba(30, 144, 255, 0.8)';
            mCtx.lineWidth = 1.5; // Adjusted for smaller size
            for (let px = 0; px < width; px++) {
                const x = px / scaleX + domain.min;
                const y = height - pdf_normal(x, mean, stdDev) * scaleY;
                if (px === 0) mCtx.moveTo(px, y);
                else mCtx.lineTo(px, y);
            }
            mCtx.stroke();
        }
        
        function drawHistogram(mCtx, data, yMaxCount) {
            if (data.length === 0 || yMaxCount === 0) return;
            const width = mCtx.canvas.width;
            const height = mCtx.canvas.height;
            const bins = new Array(numBins).fill(0);
            data.forEach(d => {
                if (d >= domain.min && d < domain.max) {
                    const binIndex = Math.floor((d - domain.min) / binWidth);
                    bins[binIndex]++;
                }
            });
            const scaleY = (height - 5) / yMaxCount; // Adjusted padding
            const scaleX = width / numBins;
            mCtx.fillStyle = 'rgba(255, 165, 0, 0.6)';
            bins.forEach((count, i) => {
                const barHeight = count * scaleY;
                mCtx.fillRect(i * scaleX, height - barHeight, scaleX - 1, barHeight);
            });
        }
        
        // Animation function
        function animate(timestamp) {
            if (timestamp - lastUpdateTime > stepDelay) {
                lastUpdateTime = timestamp;
                if (currentStep < n_iterations) {
                    currentStep++;
                }
            }
            // Main Plot
            drawBackground();
            for (let i = 0; i <= currentStep && i < chainPath.length; i++) {
                drawPoint(chainPath[i], 'rgba(0, 0, 0, 0.6)');
            }
            if (currentStep > 0 && currentStep <= history.length) {
                const latestStep = history[currentStep - 1];
                const color = latestStep.accepted ? 'rgba(30, 144, 255, 0.7)' : 'rgba(255, 0, 0, 0.45)';
                drawArrow(latestStep.start, latestStep.proposal, color, 1.5);
            }
            drawPoint(start_point, 'green', 4); // Adjusted for smaller size

            // Marginal Plots
            const acceptedPoints = chainPath.slice(0, currentStep + 1);
            const acceptedX = acceptedPoints.map(p => p.x);
            const acceptedY = acceptedPoints.map(p => p.y);

            marginalXCtx.clearRect(0, 0, marginalXCanvas.width, marginalXCanvas.height);
            drawHistogram(marginalXCtx, acceptedX, yMaxCountX);
            drawMarginalCurve(marginalXCtx, targetMean.x, targetStdDev.x);

            marginalYCtx.clearRect(0, 0, marginalYCanvas.width, marginalYCanvas.height);
            drawHistogram(marginalYCtx, acceptedY, yMaxCountY);
            drawMarginalCurve(marginalYCtx, targetMean.y, targetStdDev.y);
            
            if (currentStep >= n_iterations) {
                cancelAnimationFrame(animationFrameId);
                return;
            }
            animationFrameId = requestAnimationFrame(animate);
        }
        
        function startAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            n_iterations = parseInt(numPointsInput.value, 10);
            
            const expectedMaxCountX = n_iterations * pdf_normal(targetMean.x, targetMean.x, targetStdDev.x) * binWidth;
            yMaxCountX = expectedMaxCountX * 1.2;
            const expectedMaxCountY = n_iterations * pdf_normal(targetMean.y, targetMean.y, targetStdDev.y) * binWidth;
            yMaxCountY = expectedMaxCountY * 1.2;

            history = runMCMC(n_iterations);
            chainPath = [start_point];
            for (const step of history) {
                chainPath.push(step.accepted ? step.proposal : step.start);
            }
            currentStep = 0;
            lastUpdateTime = 0;
            animationFrameId = requestAnimationFrame(animate);
        }

        
        speedSlider.addEventListener('input', () => {
            stepDelay = parseInt(speedSlider.value, 10);
            speedValueSpan.textContent = `${stepDelay} ms`;
        });
        restartButton.addEventListener('click', startAnimation);
        window.onload = () => {
            stepDelay = parseInt(speedSlider.value, 10);
            speedValueSpan.textContent = `${stepDelay} ms`;
            startAnimation();
        };
    </script>
</body>
</html>
